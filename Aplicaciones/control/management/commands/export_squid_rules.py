from pathlib import Path
from datetime import datetime, timezone

from django.core.management.base import BaseCommand, CommandError

from Aplicaciones.control.models import Rule, Url

DAY_TO_SQUID = {
    "MON": "M",
    "TUE": "T",
    "WED": "W",
    "THU": "H",
    "FRI": "F",
    "SAT": "A",
    "SUN": "S",
}


class Command(BaseCommand):
    help = "Export active Django rules to a Squid .conf snippet."

    def add_arguments(self, parser):
        parser.add_argument(
            "--output",
            required=True,
            help="Path to output Squid config file (example: /etc/squid/conf.d/django_rules.conf)",
        )

    def handle(self, *args, **options):
        output_path = Path(options["output"]).expanduser()
        if output_path.exists() and output_path.is_dir():
            raise CommandError(f"Output path is a directory: {output_path}")

        rules = (
            Rule.objects.select_related("policy")
            .filter(
                enabled=True,
                is_delete=False,
                policy__enabled=True,
                policy__is_delete=False,
            )
            .order_by("policy_id", "priority", "rule_id")
        )

        ts = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S %Z")
        lines = [
            "# Generated by Django command: export_squid_rules",
            f"# generated_at: {ts}",
            "# Do not edit manually; regenerate from DB.",
            "",
        ]

        for rule in rules:
            domain_set = set()

            if rule.url_category_id:
                category_domains = Url.objects.filter(category_id=rule.url_category_id).values_list(
                    "host", flat=True
                )
                for host in category_domains:
                    if host:
                        domain_set.add(str(host).lower().lstrip("."))

            if not domain_set:
                # Skip rule that cannot produce dstdomain ACL.
                continue

            rid = f"rule_{rule.rule_id}"
            lines.append(f"# rule_id={rule.rule_id} policy={rule.policy.name} priority={rule.priority}")
            lines.append(f"# note: {rule.note or ''}")

            days = rule.schedule_days_list
            start = rule.schedule_start.strftime("%H:%M") if rule.schedule_start else None
            end = rule.schedule_end.strftime("%H:%M") if rule.schedule_end else None
            has_time = bool(days and start and end)
            has_time_acl = False
            if has_time:
                squid_days = "".join(DAY_TO_SQUID.get(day, "") for day in days)
                if squid_days and start and end:
                    lines.append(f"acl {rid}_time time {squid_days} {start}-{end}")
                    has_time_acl = True

            sorted_domains = sorted(domain_set)
            domains_acl = " ".join(f".{domain}" for domain in sorted_domains)
            lines.append(f"acl {rid}_domains dstdomain {domains_acl}")

            action = (rule.action or "").lower()
            if action in {"deny", "allow"}:
                if has_time_acl:
                    lines.append(f"http_access {action} {rid}_domains {rid}_time")
                else:
                    lines.append(f"http_access {action} {rid}_domains")
            else:
                lines.append(f"# skipped action={rule.action} (not supported for http_access)")

            lines.append("")

        output_path.parent.mkdir(parents=True, exist_ok=True)
        output_path.write_text("\n".join(lines).rstrip() + "\n", encoding="utf-8")

        self.stdout.write(
            self.style.SUCCESS(
                f"Exported {rules.count()} active rules to {output_path}"
            )
        )
